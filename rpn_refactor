#!/usr/bin/env bash
# title          :rpn.sh
# description    :A Reverse Polish Notation calculator
# author         :Timothy Merritt
# date           :2020-11-17
# version        :0.1.0
# usage          :./rpn.sh
# bash_version   :5.0.18(1)-release
#=========================================================

# Copy command-line arguments over to new array
ARGS=($@)
STACK=()
NUM="[-+]?[0-9]*\.?[0-9]+"

function clear_stack() {
  STACK=()
  PROMPT="${STACK[@]}> "
}

if [ ${#STACK[@]} -eq 0 ]; then
  PROMPT="${STACK[@]}> "
elif ! [ ${#STACK[@]} -eq 0 ]; then
  PROMPT="${STACK[@]} > "
fi

function is_number() {
  # Trim leading and extranneous 0s
  strip="${1#"${1%%[!0]*}"}"
  if [[ "${strip}" =~ "0" ]]; then
    shift
  fi &&
    if [[ "${strip}" =~ $NUM ]]; then
      strip=$(echo $strip 2>/dev/null | tr -dc "0-9.")
      STACK+=("${strip}") || STACK+=("${1}")
      PROMPT="${STACK[@]} > "
    fi
}

function calc() {
  op=$1
  int_1=${STACK[0]}
  int_2=${STACK[1]}
  # FIXME: ++ & -- should not replace first two digits, only first
  # if [ "$op" = "^" ]; then
  #   op="*"
  # # FIXME: Either/Or for ++/-- only removing STACK=("${STACK[@]:1}") instead of 2
  # elif [ "$op" = "++" ]; then
  #   op="+"
  #   int_2="1"
  # elif [ "$op" = "--" ]; then
  #   op="-"
  #   int_2="1"
  # fi
  result=$(echo "${int_1} $op ${int_2}" | bc -l 2>/dev/null | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
  STACK=("${STACK[@]:2}")
  STACK=($result "${STACK[@]}")
  PROMPT="${STACK[@]} > "
}

function check_stack() {
  if [ "${#STACK[@]}" -lt "2" ] && [ "$1" != "++" ] && [ "$1" != "--" ]; then
    # FIXME: Need coherent help pop-ups
    echo -e "${RED}êÑÇ ERROR${BASE}: ${1} cannot be performed on a single number."
  else
    calc "$1"
  fi
}

function parse_input() {
  while [[ "$#" -gt 0 ]]; do
    key="$1"
    is_number "$key"
    case $key in
    "q" | "quit" | "exit")
      exit 0
      ;;
    "h")
      echo "Help"
      ;;
    "clr")
      clear_stack
      shift
      ;;
    "+" | "-" | "^" | "/" | "%")
      check_stack "$key"
      shift
      ;;
    *)
      shift
      ;;
    esac
  done
}

function get_input() {
  ##########################################################################
  # Parse options

  ##########################################################################

  # Read in from piped input, if present, and append to newly-created array
  if [ ! -t 0 ]; then
    readarray STDIN_ARGS </dev/stdin
    ARGS=($@ ${STDIN_ARGS[@]})
  fi
  # Single loop to process all arguments
  for ARG in "${ARGS[@]}"; do
    is_number $ARG
  done
  # If piped input, print only final STACK
  if [ ! -t 0 ]; then
    echo "${STACK[@]}"
  fi
  ##########################################################################
  PROMPT="${STACK[@]} > "
  while read -p "${PROMPT}" INPUT; do
    parse_input $INPUT
  done
}

while getopts ":hi" arg; do
  case ${arg} in
  h)
    echo "h called"
    ;;
  i)
    echo "Interactive Mode"
    get_input
    ;;
  ?)
    echo "Invalid option: -${OPTARG}"
    ;;
  esac
done
